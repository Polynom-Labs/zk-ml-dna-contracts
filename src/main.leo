// The 'zkdna' program.
program zk_ml_dna_v0.aleo {

    struct PatientAnswers {
        hadDesease: bool,
        age: i8,
        gender: i8 // 0/1/2 male/female/other
    }

    struct BiometricInput {
        x5: i8, x7: i8, x11: i8, x12: i8, x15: i8, x20: i8, x21: i8, x25: i8, x27: i8, x31: i8
    }

    // research id to distributed rewards amount,
    mapping distributed_rewards: u64 => u128;

    // biometric input hash to true
    mapping submitted_biometric_inputs: field => bool;

    record RewardToken {
        owner: address,
        amount: u128
    }

    record AnswersWithModelOutput {
        owner: address,
        answers: PatientAnswers,
        model_out: i8
    }

    transition submit(answers: PatientAnswers, model_input: BiometricInput) -> (AnswersWithModelOutput, RewardToken) {
        let model_input_hash: field = BHP256::hash_to_field(model_input);

        // hardcode reward amount and researcher address for now
        let reward_amount: u128 = 1000u128;
        let researcher_address: address = aleo166zhnal73jv875wzsf6g75lutn56uj9tvxdfp3qgrawnk0nf3uzq25sqqv;

        // evaluate ML model againts provided input
        let model_out: i8 = model(
        model_input.x5,
        model_input.x7,
        model_input.x11,
        model_input.x12,
        model_input.x15,
        model_input.x20,
        model_input.x21,
        model_input.x25,
        model_input.x27,
        model_input.x31
        );

        return (AnswersWithModelOutput {
            owner: researcher_address, // answers and model output are private and belongs to researcher only
            answers: answers,
            model_out: model_out
        },
            RewardToken {
            owner: self.caller, // reward token goes to caller
            amount: reward_amount

        }) then finalize(model_input_hash, reward_amount);
    }

    finalize submit(model_input_hash: field, reward_amount: u128) {
        // check that it is new data, later add signature check to protect againts fraudelent inputs
        assert (!Mapping::contains(submitted_biometric_inputs, model_input_hash));

        // update total distributed rewards per research
        let research_id: u64 = 1u64;
        let current_amount: u128 = Mapping::get_or_use(distributed_rewards, research_id, 0u128);
        Mapping::set(distributed_rewards, research_id, current_amount + reward_amount);

        // publicly store hash of submitted biometric input
        Mapping::set(submitted_biometric_inputs, model_input_hash, true);
    }

    // autogenerated by zkml transpiler
    function model (x5: i8, x7: i8, x11: i8, x12: i8, x15: i8, x20: i8, x21: i8, x25: i8, x27: i8, x31: i8) -> i8 {
        if x25 <= 8i8 {
            if x11 <= 8i8 {
                if x12 <= 8i8 {
                    return 112i8;
                }
                else {
                    if x7 <= 8i8 {
                        return 48i8;
                    }
                    else {
                        return 127i8;
                    }
                }
            }
            else {
                if x27 <= 8i8 {
                    if x20 <= 8i8 {
                        return 64i8;
                    }
                    else {
                        return 14i8;
                    }
                }
                else {
                    if x21 <= 8i8 {
                        if x5 <= 8i8 {
                            if x15 <= 8i8 {
                                return 32i8;
                            }
                            else {
                                if x31 <= 8i8 {
                                    return 96i8;
                                }
                                else {
                                    return 80i8;
                                }
                            }
                        }
                        else {
                            return 16i8;
                        }
                    }
                    else {
                        return 0i8;
                    }
                }
            }
        }
        else {
            return 10i8;
        }
    }

}
